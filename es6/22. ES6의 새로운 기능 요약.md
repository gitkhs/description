## ES6의 새로운 기능 개요 [목 차](https://github.com/gitkhs/description/blob/master/es6/00.%20index.md)

1. ES6 기능의 범주
2. 새로운 번호 및 Math 기능
	* 정수 리터럴
	* Number 속성
	* Math 메소드
3. 문자열 기능
4. 심볼
	* 고유한 속성키
	* 개념을 나타내는 상수
	* 심볼은 문자열로 바꿀수 없다.
	* 심볼로 사용된 속성키를 알수 있는 방법
5. 템플릿 리터럴
6. 변수 및 범위 지정
	* let
	* const
7. 디스트럭처링
	* 객체의 디스트럭처링
	* 배열의 디스트럭처링
	* 디스트럭처링은 어디에서 사용할 수 있나
8. 매개 변수 처리
	* 디폴트 변수
	* 나머지 연산자
	* 아규먼트의 디스트럭처링
	* 스프레드 연산자
9. ES6의 호출 가능 엔티티
10. 화살표 함수
11. 클래스외 새로운 OOP기능
	* 새로운 객체 리터럴 기능
	* Object 의 새로운 메소드
12. 클래스
13. 모듈
	* 여러개의 명명된 내보내기
	* 단일 기본 내보내기
14. for-of 루프
15. 배열의 새기능
16. Map, Set
	* Map
	* Set
	* WeakMap, WeakSet
17. 형식화 된 배열
18. 반복문과 반복자
	* 반복 가능한 값
	* 반복을 지원하는 구조
19. 제너레이터
	* 제너레이터란
	* 제너레이터의 종류
	* 사례: 이터러블의 구현
	* 사례: 보다 단순한 비동기코드
	* 사례: 비동기 데이터 수신
20. 새로운 정규 표현식
21. 프로미스
	* then() 호출을 통한 체이닝
	* 비동기 함수를 병렬로 실행하기
	* 프로미스 용어
22. 프록시와 메타 프로그래밍

----------


ES6 기능의 범주
--------------
* 이미 존재하는 기능에 대한 개선된 기능
	- 클래스
	- 모듈
* 표준 라이브러리의 새로운 기능
	- 문자열 및 배열의 새로운 메소드
	- 프로미스
	- Map, Set
* 완전히 새로운 기능
	- 제너레이터
	- 프록시
	- weak

새로운 Number 및 Math 기능
----------------------
### 정수 리터럴
2진수와 8진수의 정수를 지정 할 수 있다.
* 16진수: 0xFF	(ES5)
* 2진수: 0b11	(ES6)
* 8진수: 0o10	(ES6)

### Number 속성
전역객체 Number의 새로운 속성
* *Number.EPSILON* 부동 소수점 수와 반올림 오류 허용 오차 비교
* *Number.isInteger()* 값이 정수 인지 검사한다.
* 자바스크립트 정수가 범위내에 있는지(정밀도 손실없는 부호있는 53 비트 범위)를 결정하기 위한 방법 및 상수
	- Number.isSafeInteger(number)
	- Number.MIN_SAFE_INTEGER
	- Number.MAX_SAFE_INTEGER
* *Number.isNaN(num)* 값이 `NaN`인지 여부를 확인한다. 인수를 숫자로 강제 변화 하지 않으므로 비 숫자의 경우 더 안전하게 사용 할 수 있다.
* 기존 함수와 거의 같은 기능을 가지고 있다.
	- Number.isFinite
	- Number.parseFloat
	- Number.parseInt

### Math 메소드
전역객체 Math에는 숫자, 삼각함수 및 비트 연산에 대한 새로운 메소드를 제공한다.
* *Math.sign(-8)* 숫자에 대한 부호를 반환
* *Math.trunc()* 숫자의 소수부분을 제거
* *Math.log10()* 10을 기준으로 로그계산
* *Math.hypot()* 인수의 제곱합에 대한 제곱근 계산

문자열 기능
----------
### 새로운 문자열 메소드
```javascript
'hello'.startsWith('hell')		// true
'hello'.endsWith('ello')		// true
'hello'.includes('ell')			// true
'do'.repeat(3)					// dododo
```

### 새로운 유형의 템플릿 리터럴
템플릿 리터럴은 여러 줄에 걸처 표현식을 보간 할 수 있는 새로운 종류의 문자열 리터럴이다.
리터럴 자체는 백틱(**`**)으로 구분되며 **${}** 리터럴 내부의 치환 표현식과 구분된다.
탬플릿 리터럴은 항상 문자열을 생성한다.

심볼
----
ES6의 새로운 기본 유형으로 팩토리 함수를 통해 생성된다.
```javascript
const mySymbol = Symbol('mySymbol');
```
팩토리 함수 Symbol()을 통해 받을때 마다 새로운 심볼이 생성된다.

### 고유한 속성키
심볼은 주로 고유한 속성키로 사용된다. 심볼은 다른 속성키와 충돌하지 않는다.

### 개념을 나타내는 상수
ES5에서는 문자열을 사용하여 색상과 같은 개념을 표현했다.
ES6에서는 심볼을 사용할 수 있으며 항상 고유한 값이다.
```javascript
const COLOR_RED = Symbol('Red');
const COLOR_ORANGE = Symbol('Orange');

function getComplement(color) {
	switch(color){
	case COLOR_RED:
		break;
	case COLOR_ORANGE:
		break;
	default:
		throw new Exception('Unknown color' + color);
	}
}
```

### 심볼은 문자열로 바꿀수 없다.
심볼은 문자열로 강제(암시적인 변환) 변환 할수 없다.

### 심볼로 사용된 속성키를 알수 있는 방법
**심볼을 인식하는 작업**
* Reflect.ownKeys()
* []를 통한 접근
* Object.assign()

**심볼을 무시하는 작업**
* Object.keys()
* Object.getOwnPropertyNames()
* for-in

템플릿 리터럴
-----------
ES6 에는 템플릿 리터럴과 태그가 지정된 템플릿 리터럴 2종류의 리터럴이 있다.

### 템플릿 리터럴
치환을 지원하는 여러줄 문자열 기능을 지원한다.
```javascript
const temp = 'aaa';
console.log(`
Hellow ${temp}
`);
```

### 태그 템플릿 리터럴
태그가 붙은 함수 호출하는 기능을 지원한다.
`String.raw`는 원시 형태의 문자열을 출력해주는 기능이 있다. 예로 백슬레시를 그대로 출력한다.
```javascript
String.raw`A \ tagged`;
```

변수 및 범위 지정
---------------
ES6에서 변수 선언으로 `let` 와 `const`를 제공한다. ES5의 `var` 와 유사하게 사용할 수 있다.

### let
`var`와 비슷하게 동작 하지만 변수는 블록`{}`에 한정된 범위를 가진다.

### const
`let`와 비슷한 동작 하지만 한번 선어된 값을 다시 변경할 수 없다.

디스트럭처링
-----------
디스트럭처링은 객체 및 배열에 저장된 데이터에서 여러 값을 추출하는 편리한 방법이다.
데이터를 받는 위치에서 사용할 수 있으며, 값을 추출하는 방법은 패턴을 통해 지정된다.

### 객체의 디스트럭처링
```javascript
const obj = {first:'1', last:'2'};
const {first: f, last: l} = obj;
// 아래와 같다.
// const f = obj.first;
// const l = obj.last;
```

### 배열의 디스트럭처링
반복가능한 모든 값에 동일하게 작동한다.
```javascript
const iter = [1,2,3];
const [x,y] = iter;
// 아래와 같다.
// const x = iter[0];
// const y = iter[1];
```

### 디스트럭처링은 어디에서 사용할 수 있나
```javascript
// 변수의 선언 및 초기화
const [x,y] = [1,2];
// 변수의 할당
let x, y;
[x,y] = [1,2];
// 파라메터 전달
function a([x, y]) {
	console.log(x, y);
}
a([1, 2])
// for-of 루프
for(const [k,v] of Object.entries({a:1, b:2}))
```

매개 변수 처리
------------
매개 변수 처리는 ECMAScript 6에서 상당히 업그레이드 되었다.
아규먼트의 기본값, 나머지 연산자 및 디스트럭처링을 지원한다.
스프레드 연산자는 함수 / 메서드 / 생성자 호출 및 배열 리터럴을 지원한다.

### 디폴트 변수
디폴트 변수 값은 등호`=`를 통해 지정한다. 호출자가 파라메터에 값을 제공하지 않으면 기본값이 사용된다.
```javascript
function func(x, y=0) {
    console.log(x, y);
}
func(1, 2);    // 1, 2
func(1);       // 1, 0
func();        // undefined, 0
```

### 나머지 연산자
나머지 연산자 ( ...)로 아규먼트 이름의 접두사로 사용하면 해당 아규먼트는 Array를 통해 변수를 모두받는다.
```javascript
function func(x, ...y) {
    console.log({x, y});
}
func(1, 2, 3);  // {x: 1, y: [2, 3]}
func();         // {x: undefined, y:[]}
```

### 아규먼트의 디스트럭처링
아규먼트 목록에서 객체 패턴을 사용하여 디스트럭처링을 사용하면 명명 된 변수의 값으로 전달 받을 수 있다.
```javascript
function func({x=0, y=-1, z=1 } = {}) {
    console.log(x, y, z);
}

func({x: 10, y: 30, z: 2});  // 10, 30, 2
func({z: 3});                // 0, -1, 3
func({});                    // 0, -1, 1
func();                      // undefined, undefined, undefined
```

### 스프레드 연산자
함수 및 생성자 호출에서 스프레드 연산자(...)는 반복 가능한 값을 인수로 변환한다.
```javascript
Math.max(-1, 5, 11, 3);            // 11
Math.max(...[-1, 5, 11, 3]);       // 11
Math.max(-1, ...[-1, 5, 11], 3);   // 11
console.log(...[1, ...[2,3], 4]);  // 1, 2, 3, 4
```

ES6의 호출 가능 엔티티
--------------------
ES5에서 함수 선언(전통적인) 기능은 세 가지 역할을 수행했다.
* 실제함수 (non-method)
* 메소드
* 생성자

ES6에는 더 많이 전문화 되었다. 세 가지 의무는 이제 다음과 같이 처리됩니다 (클래스 정의는 클래스를 생성하는 두 가지 구문 중 하나, 즉 클래스 선언 또는 클래스 표현식 중 하나입니다).
* 실제함수 (non-method)
	- 화살표 함수 (함수 표현식 만 가능)
	- 전통적인 함수 (함수 표현식과 함수 선언을 통해 생성됨)
	- 생성기 함수 (생성기 함수식과 생성기 함수 선언을 통해 생성됨)
* 메소드
	- 메소드 (객체 리터럴 및 클래스 정의의 메소드 정의로 작성)
	- 생성자 메소드 (객체 리터럴 및 클래스 정의의 생성자 메소드 정의로 작성)
* 생성자
	- 클래스 (클래스 정의를 통해 생성됨)

그들의 행동이 다르긴하지만, 모든 엔티티는 함수이다.
```javascript
// 화살표 함수
> typeof (() => {})       // function
// 제너레이터 함수
> typeof function* () {}  // function
// 클래스
> typeof class {}         // function
```

화살표 함수
----------
첫째. 화살표 함수는 전통적인 함수 표현보다 간략하다.
```javascript
const arr = [1, 2, 3];
console.log(arr.map(x => x * x));
```

둘째. `this` 주변 환경에 따라(어휘에 따라) 선택됩니다. 따라서, `bind()`또는 `that = this`같은 형식은 필요하지 않는다.
```javascript
function UiComponent() {
    const button = document.getElementById('myButton');
    button.addEventListener('click', () => {
        console.log('CLICK');
        this.handleClick(); // lexical `this`
    });
}
```
다음 변수들은 모두 어휘 함수 안에있는 화살표 함수입니다.
* arguments
* super
* this
* new.target


새로운 OOP기능
---------------------
### 새로운 객체 리터럴 기능

메소드 정의
```javascript
const obj = {
    myMethod(x, y) {
        ···
    }
};
```
속성 값의 약식표현
```javascript
const x = 'xxx';
const y = 'yyy';

const obj = { x, y };
// Same as:
const obj = { x: x, y: y };
```
계산 된 속성 키 사용
```javascript
const propKey = 'foo';
const obj = {
    [propKey]: true,
    ['b'+'ar']: 123,
	['h'+'ello']() {
        return 'hi';
    }
};
```

### Object 의 새로운 메소드
Object 메소드의 가장 새로은 기능은 `assign()` 이다. 고전적인 자바스크립트 방식으로는 프로퍼티 확장, 상속을 통해서 이루어 진다. 고전적인 것과는 달리 Object.assign()는 연산이 작동하는 자체(상속되지 않은)속성만 고려 한다.
```javascript
const obj = { foo: 123 };
Object.assign(obj, { bar: true });
console.log(obj);    // {"foo":123,"bar":true}
```

클래스
-----
클래스와 서브 클래스
```javascript
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color;
    }
}
```
ES6에서 클래스는 근본적으로 새로운 것이 아니다. 주로 구식 생성자(프로토타입 체이닝) 함수를 만드는데 더 편리한 구문을 제공한다.

모듈
----
JavaScript에는 오랫동안 모듈이 있었다. 그러나 이들은 언어로 구축되지 않은 라이브러리를 통해 구현되었다. ES6는 자바스크립트에 모듈 기능이 내장 되었다.

ES6에서 모듈은 파일에 저장다. 파일 당 정확히 하나의 모듈과 모듈 당 하나의 파일이 있다. 모듈에서 물건을 내보내는 두 가지 방법이 있다. 이 두 가지 방법을 혼합 할 수 는 있지만 대개 별도로 사용하는 것이 좋다.

### 여러개의 명명된 내보내기
```javascript
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
	return x * x;
}
export function diag(x, y) {
	return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11));  // 121
console.log(diag(4, 3));  // 5
```
전체 모듈을 가져올 수도 있다.
```javascript
//------ main.js ------
import * as lib from 'lib';
console.log(lib.square(11));  // 121
console.log(lib.diag(4, 3));  // 5
```

### 단일 기본 내보내기
```javascript
//------ myFunc.js ------
export default function () { ··· } // no semicolon!

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();
```
또는 클래스
```javascript
//------ MyClass.js ------
export default class { ··· } // no semicolon!

//------ main2.js ------
import MyClass from 'MyClass';
const inst = new MyClass();
```
**함수 또는 클래스(익명 선언)를 기본 내보내기하는 경우에는 끝에 세미콜론을 사용하지 않는다.**

for-of 루프
-----------
배열의 새기능
------------
Map, Set
--------
### Map
### Set
### WeakMap, WeakSet
형식화 된 배열
------------
반복문과 반복자
-------------
### 반복 가능한 값
### 반복을 지원하는 구조
제너레이터
---------
### 제너레이터란
### 제너레이터의 종류
### 사례: 이터러블의 구현
### 사례: 보다 단순한 비동기코드
### 사례: 비동기 데이터 수신
새로운 정규 표현식
----------------
프로미스
-------
### then() 호출을 통한 체이닝
### 비동기 함수를 병렬로 실행하기
### 프로미스 용어
프록시와 메타 프로그래밍
---------------------
